// This file was auto-generated by Fern from our API Definition.

package networkscan

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/Method-Security/networkscan/generated/go/core"
	time "time"
)

type BannerGrab struct {
	Host        string            `json:"host" url:"host"`
	Ip          string            `json:"ip" url:"ip"`
	Port        int               `json:"port" url:"port"`
	Tls         bool              `json:"tls" url:"tls"`
	Version     string            `json:"version" url:"version"`
	Transport   TransportType     `json:"transport" url:"transport"`
	Protocol    ProtocolType      `json:"protocol" url:"protocol"`
	StatusCode  *string           `json:"statusCode,omitempty" url:"statusCode,omitempty"`
	Connection  *string           `json:"connection,omitempty" url:"connection,omitempty"`
	ContentType *string           `json:"contentType,omitempty" url:"contentType,omitempty"`
	SameSite    *SameSiteType     `json:"sameSite,omitempty" url:"sameSite,omitempty"`
	Metadata    map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BannerGrab) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BannerGrab) UnmarshalJSON(data []byte) error {
	type unmarshaler BannerGrab
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BannerGrab(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BannerGrab) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BannerGrabReport struct {
	Target      string        `json:"target" url:"target"`
	BannerGrabs []*BannerGrab `json:"bannerGrabs,omitempty" url:"bannerGrabs,omitempty"`
	Errors      []string      `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BannerGrabReport) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BannerGrabReport) UnmarshalJSON(data []byte) error {
	type unmarshaler BannerGrabReport
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BannerGrabReport(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BannerGrabReport) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type CookieInfo struct {
	Data       string    `json:"data" url:"data"`
	Expiration time.Time `json:"expiration" url:"expiration"`
	Samesite   bool      `json:"samesite" url:"samesite"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CookieInfo) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CookieInfo) UnmarshalJSON(data []byte) error {
	type embed CookieInfo
	var unmarshaler = struct {
		embed
		Expiration *core.DateTime `json:"expiration"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CookieInfo(unmarshaler.embed)
	c.Expiration = unmarshaler.Expiration.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CookieInfo) MarshalJSON() ([]byte, error) {
	type embed CookieInfo
	var marshaler = struct {
		embed
		Expiration *core.DateTime `json:"expiration"`
	}{
		embed:      embed(*c),
		Expiration: core.NewDateTime(c.Expiration),
	}
	return json.Marshal(marshaler)
}

func (c *CookieInfo) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ProtocolType string

const (
	ProtocolTypeDns        ProtocolType = "DNS"
	ProtocolTypeDhcp       ProtocolType = "DHCP"
	ProtocolTypeEcho       ProtocolType = "ECHO"
	ProtocolTypeFtp        ProtocolType = "FTP"
	ProtocolTypeHttp       ProtocolType = "HTTP"
	ProtocolTypeHttps      ProtocolType = "HTTPS"
	ProtocolTypeHttp2      ProtocolType = "HTTP2"
	ProtocolTypeImap       ProtocolType = "IMAP"
	ProtocolTypeImaps      ProtocolType = "IMAPS"
	ProtocolTypeIpmi       ProtocolType = "IPMI"
	ProtocolTypeIpsec      ProtocolType = "IPSEC"
	ProtocolTypeJdwp       ProtocolType = "JDWP"
	ProtocolTypeKafka      ProtocolType = "KAFKA"
	ProtocolTypeLdap       ProtocolType = "LDAP"
	ProtocolTypeLdaps      ProtocolType = "LDAPS"
	ProtocolTypeModbus     ProtocolType = "MODBUS"
	ProtocolTypeMqtt       ProtocolType = "MQTT"
	ProtocolTypeMssql      ProtocolType = "MSSQL"
	ProtocolTypeMysql      ProtocolType = "MYSQL"
	ProtocolTypeNetbios    ProtocolType = "NETBIOS"
	ProtocolTypeNtp        ProtocolType = "NTP"
	ProtocolTypeOracle     ProtocolType = "ORACLE"
	ProtocolTypeOpenvpn    ProtocolType = "OPENVPN"
	ProtocolTypePop3       ProtocolType = "POP3"
	ProtocolTypePop3S      ProtocolType = "POP3S"
	ProtocolTypePostgresql ProtocolType = "POSTGRESQL"
	ProtocolTypeRdp        ProtocolType = "RDP"
	ProtocolTypeRpc        ProtocolType = "RPC"
	ProtocolTypeRedis      ProtocolType = "REDIS"
	ProtocolTypeRsync      ProtocolType = "RSYNC"
	ProtocolTypeRtsp       ProtocolType = "RTSP"
	ProtocolTypeSmb        ProtocolType = "SMB"
	ProtocolTypeSmtp       ProtocolType = "SMTP"
	ProtocolTypeSmtps      ProtocolType = "SMTPS"
	ProtocolTypeSnmp       ProtocolType = "SNMP"
	ProtocolTypeSsh        ProtocolType = "SSH"
	ProtocolTypeStun       ProtocolType = "STUN"
	ProtocolTypeTelnet     ProtocolType = "TELNET"
	ProtocolTypeVnc        ProtocolType = "VNC"
	ProtocolTypeUnknown    ProtocolType = "UNKNOWN"
)

func NewProtocolTypeFromString(s string) (ProtocolType, error) {
	switch s {
	case "DNS":
		return ProtocolTypeDns, nil
	case "DHCP":
		return ProtocolTypeDhcp, nil
	case "ECHO":
		return ProtocolTypeEcho, nil
	case "FTP":
		return ProtocolTypeFtp, nil
	case "HTTP":
		return ProtocolTypeHttp, nil
	case "HTTPS":
		return ProtocolTypeHttps, nil
	case "HTTP2":
		return ProtocolTypeHttp2, nil
	case "IMAP":
		return ProtocolTypeImap, nil
	case "IMAPS":
		return ProtocolTypeImaps, nil
	case "IPMI":
		return ProtocolTypeIpmi, nil
	case "IPSEC":
		return ProtocolTypeIpsec, nil
	case "JDWP":
		return ProtocolTypeJdwp, nil
	case "KAFKA":
		return ProtocolTypeKafka, nil
	case "LDAP":
		return ProtocolTypeLdap, nil
	case "LDAPS":
		return ProtocolTypeLdaps, nil
	case "MODBUS":
		return ProtocolTypeModbus, nil
	case "MQTT":
		return ProtocolTypeMqtt, nil
	case "MSSQL":
		return ProtocolTypeMssql, nil
	case "MYSQL":
		return ProtocolTypeMysql, nil
	case "NETBIOS":
		return ProtocolTypeNetbios, nil
	case "NTP":
		return ProtocolTypeNtp, nil
	case "ORACLE":
		return ProtocolTypeOracle, nil
	case "OPENVPN":
		return ProtocolTypeOpenvpn, nil
	case "POP3":
		return ProtocolTypePop3, nil
	case "POP3S":
		return ProtocolTypePop3S, nil
	case "POSTGRESQL":
		return ProtocolTypePostgresql, nil
	case "RDP":
		return ProtocolTypeRdp, nil
	case "RPC":
		return ProtocolTypeRpc, nil
	case "REDIS":
		return ProtocolTypeRedis, nil
	case "RSYNC":
		return ProtocolTypeRsync, nil
	case "RTSP":
		return ProtocolTypeRtsp, nil
	case "SMB":
		return ProtocolTypeSmb, nil
	case "SMTP":
		return ProtocolTypeSmtp, nil
	case "SMTPS":
		return ProtocolTypeSmtps, nil
	case "SNMP":
		return ProtocolTypeSnmp, nil
	case "SSH":
		return ProtocolTypeSsh, nil
	case "STUN":
		return ProtocolTypeStun, nil
	case "TELNET":
		return ProtocolTypeTelnet, nil
	case "VNC":
		return ProtocolTypeVnc, nil
	case "UNKNOWN":
		return ProtocolTypeUnknown, nil
	}
	var t ProtocolType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ProtocolType) Ptr() *ProtocolType {
	return &p
}

type SameSiteType string

const (
	SameSiteTypeNone    SameSiteType = "NONE"
	SameSiteTypeLax     SameSiteType = "LAX"
	SameSiteTypeStrict  SameSiteType = "STRICT"
	SameSiteTypeUnknown SameSiteType = "UNKNOWN"
)

func NewSameSiteTypeFromString(s string) (SameSiteType, error) {
	switch s {
	case "NONE":
		return SameSiteTypeNone, nil
	case "LAX":
		return SameSiteTypeLax, nil
	case "STRICT":
		return SameSiteTypeStrict, nil
	case "UNKNOWN":
		return SameSiteTypeUnknown, nil
	}
	var t SameSiteType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SameSiteType) Ptr() *SameSiteType {
	return &s
}

type TransportType string

const (
	TransportTypeTcp     TransportType = "TCP"
	TransportTypeUdp     TransportType = "UDP"
	TransportTypeUnknown TransportType = "UNKNOWN"
)

func NewTransportTypeFromString(s string) (TransportType, error) {
	switch s {
	case "TCP":
		return TransportTypeTcp, nil
	case "UDP":
		return TransportTypeUdp, nil
	case "UNKNOWN":
		return TransportTypeUnknown, nil
	}
	var t TransportType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransportType) Ptr() *TransportType {
	return &t
}
