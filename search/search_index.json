{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"networkscan Documentation","text":"<p>Hello and welcome to the networkscan documentation. While we always want to provide the most comprehensive documentation possible, we thought you may find the below sections a helpful place to get started.</p> <ul> <li>The Getting Started section provides onboarding material</li> <li>The Development header is the best place to get started on developing on top of and with networkscan</li> <li>See the Docs section for a comprehensive rundown of networkscan capabilities</li> </ul>"},{"location":"index.html#about-networkscan","title":"About networkscan","text":"<p>networkscan offers security teams a data-rich network scanning and enumeration techniques to help them gain visibility into all of their cloud and on-premise environments. Designed with data-modeling and data-integration needs in mind, networkscan can be used on its own as an interactive CLI, orchestrated as part of a broader data pipeline, or leveraged from within the Method Platform.</p> <p>The types of scans that networkscan can conduct are constantly growing. For the most up to date listing, please see the documentation here</p> <p>To learn more about networkscan, please see the Documentation site for the most detailed information.</p>"},{"location":"index.html#quick-start","title":"Quick Start","text":""},{"location":"index.html#get-networkscan","title":"Get networkscan","text":"<p>For the full list of available installation options, please see the Installation page. For convenience, here are some of the most commonly used options:</p> <ul> <li><code>docker run methodsecurity/networkscan</code></li> <li><code>docker run ghcr.io/method-security/networkscan</code></li> <li>Download the latest binary from the Github Releases page</li> <li>Installation documentation</li> </ul>"},{"location":"index.html#general-usage","title":"General Usage","text":"<pre><code>networkscan port scan --target &lt;target&gt;\n</code></pre>"},{"location":"index.html#examples","title":"Examples","text":"<pre><code>networkscan port scan --topports 100 --target scanme.sh\n</code></pre>"},{"location":"index.html#contributing","title":"Contributing","text":"<p>Interested in contributing to networkscan? Please see our organization wide Contribution page.</p>"},{"location":"index.html#want-more","title":"Want More?","text":"<p>If you're looking for an easy way to tie networkscan into your broader cybersecurity workflows, or want to leverage some autonomy to improve your overall security posture, you'll love the broader Method Platform.</p> <p>For more information, visit us here</p>"},{"location":"index.html#community","title":"Community","text":"<p>networkscan is a Method Security open source project.</p> <p>Learn more about Method's open source source work by checking out our other projects here or our organization wide documentation here.</p> <p>Have an idea for a Tool to contribute? Open a Discussion here.</p>"},{"location":"community/community.html","title":"Contributing","text":"<p>For more information on how to get involved in the Method community, please see our organization wide documentation:</p> <ul> <li>Discussions</li> <li>Issues</li> <li>Pull Requests</li> </ul>"},{"location":"development/adding.html","title":"Adding a new capability","text":"<p>By design, networkscan breaks every unique network scan into its own top level command. If you are looking to add a brand new capability to the tool, you can take the following steps.</p> <ol> <li>Add a file to <code>cmd/</code> that corresponds to the sub-command name you'd like to add to the <code>networkscan</code> CLI</li> <li>You can use <code>cmd/port.go</code> as a template</li> <li>Your file needs to be a member function of the <code>networkscan</code> struct and should be of the form <code>Init&lt;cmd&gt;Command</code></li> <li>Add a new member to the <code>networkscan</code> struct in <code>cmd/root.go</code> that corresponsds to your command name. Remember, the first letter must be capitalized.</li> <li>Call your <code>Init</code> function from <code>main.go</code></li> <li>Add logic to your commands runtime and put it in its own package within <code>internal</code> (e.g., <code>internal/port</code>)</li> </ol>"},{"location":"development/principles.html","title":"Project Principles","text":""},{"location":"development/principles.html#pre-run-run-post-run","title":"Pre-run -&gt; Run -&gt; Post-run","text":"<p>In the root command, we set a <code>PersistentPreRunE</code> and <code>PersistentPostRunE</code> function that is responsible for initializing the output format and Signal data (in the pre-run) and then write that data in the proper format (in the post-run).</p> <p>Within the Run command that every command must implement, the output of the collected data needs to be written back to the struct's <code>OutputSignal.Content</code> value in order to be properly written out to the caller.</p>"},{"location":"development/principles.html#cmd-vs-internal","title":"Cmd vs Internal","text":"<p>By design, the functionality within each command should focus around parsing the variety of flags and options that the command may need to control capability, passing off all real logic into internal modules.</p>"},{"location":"development/setup.html","title":"Development Setup","text":""},{"location":"development/setup.html#adding-a-new-capability","title":"Adding a new capability","text":"<p>To add a new scan to networkscan, providing new enumeration capabilities to security operators everywhere, please see the adding a new capability page.</p>"},{"location":"development/setup.html#setting-up-your-development-environment","title":"Setting up your development environment","text":"<p>If you've just cloned networkscan for the first time, welcome to the community! We use Palantir's godel to streamline local development and goreleaser to handle the heavy lifting on the release process.</p> <p>To get started with godel, you can run</p> <pre><code>./godelw verify\n</code></pre> <p>This will run a number of checks for us, including linters, tests, and license checks. We run this command as part of our CI pipeline to ensure the codebase is consistently passing tests.</p>"},{"location":"development/setup.html#building-the-cli","title":"Building the CLI","text":"<p>We can use godel to build our CLI locally by running</p> <pre><code>./godelw build\n</code></pre> <p>You should see output in <code>out/build/networkscan/&lt;version&gt;/&lt;os&gt;-&lt;arch&gt;/networkscan</code>.</p> <p>If you'd like to clean this output up, you can run</p> <pre><code>./godelw clean\n</code></pre>"},{"location":"development/setup.html#compile-and-run-in-single-step","title":"Compile and Run in single step","text":"<p>If you are developing a new command or subcommand, and want to test, you can run with:</p> <pre><code>go run main.go &lt;command&gt;\n</code></pre> <p>For example, the following commands would be the same, but the former requires building the CLI first:</p> <pre><code>networkscan port scan --target scanme.sh\ngo run main.go port scan --target scanme.sh\n</code></pre> <p>If you are dealing with a command or subcommand that requires a privileged user to run, on a Unix based machine a quick way to do this is:</p> <pre><code>sudo $(which go) run main.go host discover --target 192.168.0.0/24\n</code></pre>"},{"location":"development/setup.html#testing-releases-locally","title":"Testing releases locally","text":"<p>We can use goreleaser locally as well to test our builds. As networkscan uses cosign to sign our artifacts and Docker containers during our CI pipeline, we'll want to skip this step when running locally.</p> <pre><code>goreleaser release --snapshot --clean --skip sign\n</code></pre> <p>This should output binaries, distributable tarballs/zips, as well as docker images to your local machine's Docker registry.</p>"},{"location":"docs/index.html","title":"Capabilities","text":"<p>networkscan offers a variety of scanning techniques to security teams working across all cloud providers and on-premise environments. Each of the below pages offers you an in depth look at a networkscan capability related to a unique scanning technique.</p> <ul> <li>Port</li> <li>Host</li> <li>OS</li> </ul>"},{"location":"docs/index.html#top-level-flags","title":"Top Level Flags","text":"<p>networkscan has several top level flags that can be used on any subcommand. These include:</p> <pre><code>Flags:\n  -h, --help                 help for networkscan\n  -o, --output string        Output format (signal, json, yaml). Default value is signal (default \"signal\")\n  -f, --output-file string   Path to output file. If blank, will output to STDOUT\n  -q, --quiet                Suppress output\n  -v, --verbose              Verbose output\n</code></pre>"},{"location":"docs/index.html#version-command","title":"Version Command","text":"<p>Run <code>networkscan version</code> to get the exact version information for your binary</p>"},{"location":"docs/index.html#output-formats","title":"Output Formats","text":"<p>For more information on the various output formats that are supported by networkscan, see the Output Formats page in our organization wide documentation.</p>"},{"location":"docs/host.html","title":"Host","text":"<p>The <code>networkscan host discover</code> command discovers active network hosts.</p>"},{"location":"docs/host.html#usage","title":"Usage","text":"<p>To discover active hosts on a network (this must be run as a privileged user): <pre><code>networkscan host discover  --target 192.168.0.0/24\n</code></pre></p>"},{"location":"docs/host.html#help","title":"Help","text":"<pre><code>networkscan host discover -h\n\nDiscover hosts on a network\n\nUsage:\n  networkscan host discover [flags]\n\nFlags:\n  -h, --help              help for discover\n      --scantype string   Scan type for host discovery (tcpsyn | tcpack | icmpecho | icmptimestamp | arp | icmpaddressmask)\n      --target string     Target IP, host, or CIDR to scan for hosts\n\nGlobal Flags:\n  -o, --output string        Output format (signal, json, yaml). Default value is signal (default \"signal\")\n  -f, --output-file string   Path to output file. If blank, will output to STDOUT\n  -q, --quiet                Suppress output\n  -v, --verbose              Verbose output\n</code></pre>"},{"location":"docs/os.html","title":"OS","text":"<p>The <code>networkscan os detect</code> command detects OS across network hosts. Under the hood it leverages <code>nmap</code>.</p>"},{"location":"docs/os.html#usage","title":"Usage","text":"<p>To scan for ports on a target host (this must be run as a privileged user): <pre><code>networkscan os detect --target 192.168.1.1\n</code></pre></p>"},{"location":"docs/os.html#help","title":"Help","text":"<pre><code>networkscan os detect -h\n\nDetect the operating system on a target host\n\nUsage:\n  networkscan os detect [flags]\n\nFlags:\n  -h, --help            help for detect\n      --target string   Target IP or FQDN to detect\n\nGlobal Flags:\n  -o, --output string        Output format (signal, json, yaml). Default value is signal (default \"signal\")\n  -f, --output-file string   Path to output file. If blank, will output to STDOUT\n  -q, --quiet                Suppress output\n  -v, --verbose              Verbose output\n</code></pre>"},{"location":"docs/port.html","title":"Port","text":"<p>The <code>networkscan port scan</code> command provide information about ports that are open across networked devices.</p>"},{"location":"docs/port.html#usage","title":"Usage","text":"<p>To scan for ports on a target host: <pre><code>networkscan port scan --topports 100 --target scanme.sh\n</code></pre></p>"},{"location":"docs/port.html#help","title":"Help","text":"<pre><code>networkscan port scan -h\n\nScan for open ports on a target host\n\nUsage:\n  networkscan port scan [flags]\n\nFlags:\n  -h, --help              help for scan\n      --ports string      Port/Port Range to scan\n      --target string     Target IP to scan on\n      --topports string   Top Ports to scan [full,100,1000]\n\nGlobal Flags:\n  -o, --output string        Output format (signal, json, yaml). Default value is signal (default \"signal\")\n  -f, --output-file string   Path to output file. If blank, will output to STDOUT\n  -q, --quiet                Suppress output\n  -v, --verbose              Verbose output\n</code></pre>"},{"location":"getting-started/basic-usage.html","title":"Basic Usage","text":""},{"location":"getting-started/basic-usage.html#binaries","title":"Binaries","text":"<p>Running as a binary allows you to skip dealing with any container related networking issues and leverage the same network interface that the host machine is using.</p> <p>You can validate that the binary is working by scanning the publicly available <code>scanme.sh</code>.</p> <pre><code>networkscan port scan --topports 100 --target scanme.sh\n</code></pre>"},{"location":"getting-started/basic-usage.html#docker","title":"Docker","text":"<p>Running networkscan within a Docker container should typically work similarly to running directly on a host, however, occasionally there are a few things to keep in mind.</p> <p>If you're running on a Docker container on a MacOS machine and you are trying to scan a locally running service, you can leverage the <code>host.docker.internal</code> address as mentioned in the Docker documentation here.</p> <pre><code>docker run ghcr.io/method-security/networkscan \\\n  port scan \\\n  --topports 100 \\\n  --target scanme.sh\n</code></pre>"},{"location":"getting-started/installation.html","title":"Getting Started","text":"<p>If you are just getting started with networkscan, welcome! This guide will walk you through the process of going zero to one with the tool.</p>"},{"location":"getting-started/installation.html#installation","title":"Installation","text":"<p>networkscan is provided in several convenient form factors, including statically compiled binary images on a variety of architectures as well as a Docker image for both x86 and ARM machines.</p> <p>If you do not see an architecture that you require, please open a Discussion to propose adding it.</p>"},{"location":"getting-started/installation.html#binaries","title":"Binaries","text":"<p>networkscan currently supports statically compiled binaries across the following operating systems and architectures:</p> OS Architecture Linux amd64 Linux arm64 MacOS arm64 Windows amd64 <p>The latest binaries can be downloaded directly from Github.</p>"},{"location":"getting-started/installation.html#docker","title":"Docker","text":"<p>Docker images for networkscan are hosted in both Github Container Registry as well as on Docker Hub and can be pulled via:</p> <pre><code>docker pull ghcr.io/method-security/networkscan\n</code></pre> <pre><code>docker pull methodsecurity/networkscan\n</code></pre>"}]}