// This file was auto-generated by Fern from our API Definition.

package networkscan

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/Method-Security/networkscan/generated/go/core"
	time "time"
)

type BannerGrab struct {
	Host        string            `json:"host" url:"host"`
	Ip          string            `json:"ip" url:"ip"`
	Port        int               `json:"port" url:"port"`
	Tls         bool              `json:"tls" url:"tls"`
	Version     string            `json:"version" url:"version"`
	Transport   TransportType     `json:"transport" url:"transport"`
	Service     ServiceType       `json:"service" url:"service"`
	StatusCode  *string           `json:"statusCode,omitempty" url:"statusCode,omitempty"`
	Connection  *string           `json:"connection,omitempty" url:"connection,omitempty"`
	ContentType *string           `json:"contentType,omitempty" url:"contentType,omitempty"`
	SameSite    *SameSiteType     `json:"sameSite,omitempty" url:"sameSite,omitempty"`
	Metadata    map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BannerGrab) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BannerGrab) UnmarshalJSON(data []byte) error {
	type unmarshaler BannerGrab
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BannerGrab(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BannerGrab) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BannerGrabReport struct {
	Target      string        `json:"target" url:"target"`
	BannerGrabs []*BannerGrab `json:"bannerGrabs,omitempty" url:"bannerGrabs,omitempty"`
	Errors      []string      `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BannerGrabReport) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BannerGrabReport) UnmarshalJSON(data []byte) error {
	type unmarshaler BannerGrabReport
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BannerGrabReport(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BannerGrabReport) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type CookieInfo struct {
	Data       string    `json:"data" url:"data"`
	Expiration time.Time `json:"expiration" url:"expiration"`
	Samesite   bool      `json:"samesite" url:"samesite"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CookieInfo) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CookieInfo) UnmarshalJSON(data []byte) error {
	type embed CookieInfo
	var unmarshaler = struct {
		embed
		Expiration *core.DateTime `json:"expiration"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CookieInfo(unmarshaler.embed)
	c.Expiration = unmarshaler.Expiration.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CookieInfo) MarshalJSON() ([]byte, error) {
	type embed CookieInfo
	var marshaler = struct {
		embed
		Expiration *core.DateTime `json:"expiration"`
	}{
		embed:      embed(*c),
		Expiration: core.NewDateTime(c.Expiration),
	}
	return json.Marshal(marshaler)
}

func (c *CookieInfo) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type SameSiteType string

const (
	SameSiteTypeNone    SameSiteType = "NONE"
	SameSiteTypeLax     SameSiteType = "LAX"
	SameSiteTypeStrict  SameSiteType = "STRICT"
	SameSiteTypeUnknown SameSiteType = "UNKNOWN"
)

func NewSameSiteTypeFromString(s string) (SameSiteType, error) {
	switch s {
	case "NONE":
		return SameSiteTypeNone, nil
	case "LAX":
		return SameSiteTypeLax, nil
	case "STRICT":
		return SameSiteTypeStrict, nil
	case "UNKNOWN":
		return SameSiteTypeUnknown, nil
	}
	var t SameSiteType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SameSiteType) Ptr() *SameSiteType {
	return &s
}

type ServiceType string

const (
	ServiceTypeHttp        ServiceType = "HTTP"
	ServiceTypeHttps       ServiceType = "HTTPS"
	ServiceTypeFtp         ServiceType = "FTP"
	ServiceTypeSftp        ServiceType = "SFTP"
	ServiceTypeSsh         ServiceType = "SSH"
	ServiceTypeTelnet      ServiceType = "TELNET"
	ServiceTypeSmtp        ServiceType = "SMTP"
	ServiceTypeSmtps       ServiceType = "SMTPS"
	ServiceTypePop3        ServiceType = "POP3"
	ServiceTypePop3S       ServiceType = "POP3S"
	ServiceTypeImap        ServiceType = "IMAP"
	ServiceTypeImaps       ServiceType = "IMAPS"
	ServiceTypeDns         ServiceType = "DNS"
	ServiceTypeSnmp        ServiceType = "SNMP"
	ServiceTypeKafka       ServiceType = "KAFKA"
	ServiceTypeMqtt3       ServiceType = "MQTT3"
	ServiceTypeMqtt5       ServiceType = "MQTT5"
	ServiceTypeRdp         ServiceType = "RDP"
	ServiceTypeRedis       ServiceType = "REDIS"
	ServiceTypeLdap        ServiceType = "LDAP"
	ServiceTypeLdaps       ServiceType = "LDAPS"
	ServiceTypeRsync       ServiceType = "RSYNC"
	ServiceTypeRpc         ServiceType = "RPC"
	ServiceTypePostgressql ServiceType = "POSTGRESSQL"
	ServiceTypeMysql       ServiceType = "MYSQL"
	ServiceTypeMssql       ServiceType = "MSSQL"
	ServiceTypeOracledb    ServiceType = "ORACLEDB"
	ServiceTypeVnc         ServiceType = "VNC"
	ServiceTypeModbus      ServiceType = "MODBUS"
	ServiceTypeSmb         ServiceType = "SMB"
	ServiceTypeIpsec       ServiceType = "IPSEC"
	ServiceTypeStun        ServiceType = "STUN"
	ServiceTypeRtsp        ServiceType = "RTSP"
	ServiceTypeDhcp        ServiceType = "DHCP"
	ServiceTypeNtp         ServiceType = "NTP"
	ServiceTypeOpenvpn     ServiceType = "OPENVPN"
	ServiceTypeUnknown     ServiceType = "UNKNOWN"
)

func NewServiceTypeFromString(s string) (ServiceType, error) {
	switch s {
	case "HTTP":
		return ServiceTypeHttp, nil
	case "HTTPS":
		return ServiceTypeHttps, nil
	case "FTP":
		return ServiceTypeFtp, nil
	case "SFTP":
		return ServiceTypeSftp, nil
	case "SSH":
		return ServiceTypeSsh, nil
	case "TELNET":
		return ServiceTypeTelnet, nil
	case "SMTP":
		return ServiceTypeSmtp, nil
	case "SMTPS":
		return ServiceTypeSmtps, nil
	case "POP3":
		return ServiceTypePop3, nil
	case "POP3S":
		return ServiceTypePop3S, nil
	case "IMAP":
		return ServiceTypeImap, nil
	case "IMAPS":
		return ServiceTypeImaps, nil
	case "DNS":
		return ServiceTypeDns, nil
	case "SNMP":
		return ServiceTypeSnmp, nil
	case "KAFKA":
		return ServiceTypeKafka, nil
	case "MQTT3":
		return ServiceTypeMqtt3, nil
	case "MQTT5":
		return ServiceTypeMqtt5, nil
	case "RDP":
		return ServiceTypeRdp, nil
	case "REDIS":
		return ServiceTypeRedis, nil
	case "LDAP":
		return ServiceTypeLdap, nil
	case "LDAPS":
		return ServiceTypeLdaps, nil
	case "RSYNC":
		return ServiceTypeRsync, nil
	case "RPC":
		return ServiceTypeRpc, nil
	case "POSTGRESSQL":
		return ServiceTypePostgressql, nil
	case "MYSQL":
		return ServiceTypeMysql, nil
	case "MSSQL":
		return ServiceTypeMssql, nil
	case "ORACLEDB":
		return ServiceTypeOracledb, nil
	case "VNC":
		return ServiceTypeVnc, nil
	case "MODBUS":
		return ServiceTypeModbus, nil
	case "SMB":
		return ServiceTypeSmb, nil
	case "IPSEC":
		return ServiceTypeIpsec, nil
	case "STUN":
		return ServiceTypeStun, nil
	case "RTSP":
		return ServiceTypeRtsp, nil
	case "DHCP":
		return ServiceTypeDhcp, nil
	case "NTP":
		return ServiceTypeNtp, nil
	case "OPENVPN":
		return ServiceTypeOpenvpn, nil
	case "UNKNOWN":
		return ServiceTypeUnknown, nil
	}
	var t ServiceType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ServiceType) Ptr() *ServiceType {
	return &s
}

type TransportType string

const (
	TransportTypeTcp     TransportType = "TCP"
	TransportTypeUdp     TransportType = "UDP"
	TransportTypeUnknown TransportType = "UNKNOWN"
)

func NewTransportTypeFromString(s string) (TransportType, error) {
	switch s {
	case "TCP":
		return TransportTypeTcp, nil
	case "UDP":
		return TransportTypeUdp, nil
	case "UNKNOWN":
		return TransportTypeUnknown, nil
	}
	var t TransportType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransportType) Ptr() *TransportType {
	return &t
}
